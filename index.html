<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>スマートフォン向けシューティングゲーム</title>
    <style>
        body {
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            touch-action: none;
        }
        #gameCanvas {
            border: 2px solid #16213e;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        let canvas;
        let ctx;
        const gameState = {
            player: {
                x: 0,
                y: 0,
                width: 0,
                height: 0,
                color: '#00fff5'
            },
            bullets: [],
            enemies: [],
            scoreDisplays: [],
            penaltyScores: [],
            bulletSpeed: 7,
            isGameOver: false,
            score: 0,
            lastShotTime: 0
        };

        const enemyTypes = [
            { color: 'red', score: 20, size: 20 },
            { color: 'blue', score: 18, size: 24 },
            { color: 'purple', score: 16, size: 28 },
            { color: 'orange', score: 14, size: 32 },
            { color: 'yellow', score: 12, size: 36 },
            { color: 'green', score: 10, size: 40 }
        ];

        function createBackgroundPattern() {
            const patternCanvas = document.createElement('canvas');
            const patternContext = patternCanvas.getContext('2d');
            patternCanvas.width = canvas.width;
            patternCanvas.height = canvas.height;
            
            const gradient = patternContext.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, "#000033");
            gradient.addColorStop(1, "#000066");
            
            patternContext.fillStyle = gradient;
            patternContext.fillRect(0, 0, canvas.width, canvas.height);
            
            for (let i = 0; i < 100; i++) {
                patternContext.fillStyle = "white";
                patternContext.beginPath();
                patternContext.arc(
                    Math.random() * canvas.width,
                    Math.random() * canvas.height,
                    Math.random() * 2,
                    0,
                    Math.PI * 2
                );
                patternContext.fill();
            }
            
            return patternCanvas;
        }

        let backgroundPattern;

        function drawBackground() {
            ctx.drawImage(backgroundPattern, 0, 0);
        }

        function drawPlayer() {
            ctx.save();
            ctx.translate(gameState.player.x, gameState.player.y);

            // メインボディ
            ctx.fillStyle = gameState.player.color;
            ctx.beginPath();
            ctx.moveTo(0, -gameState.player.height / 2);
            ctx.lineTo(-gameState.player.width / 2, gameState.player.height / 2);
            ctx.lineTo(gameState.player.width / 2, gameState.player.height / 2);
            ctx.closePath();
            ctx.fill();

            // ウィング
            ctx.fillStyle = '#0099cc';
            ctx.beginPath();
            ctx.moveTo(-gameState.player.width / 2, gameState.player.height / 4);
            ctx.lineTo(-gameState.player.width * 0.7, gameState.player.height / 2);
            ctx.lineTo(-gameState.player.width / 2, gameState.player.height / 2);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(gameState.player.width / 2, gameState.player.height / 4);
            ctx.lineTo(gameState.player.width * 0.7, gameState.player.height / 2);
            ctx.lineTo(gameState.player.width / 2, gameState.player.height / 2);
            ctx.closePath();
            ctx.fill();

            // コックピット
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.ellipse(0, -gameState.player.height / 6, gameState.player.width / 6, gameState.player.height / 8, 0, 0, Math.PI * 2);
            ctx.fill();

            // エンジンの光
            ctx.fillStyle = '#ff9900';
            ctx.beginPath();
            ctx.moveTo(-gameState.player.width / 4, gameState.player.height / 2);
            ctx.lineTo(0, gameState.player.height * 0.7);
            ctx.lineTo(gameState.player.width / 4, gameState.player.height / 2);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }

        function drawBullets() {
            ctx.fillStyle = '#ff4766';
            gameState.bullets.forEach(bullet => {
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, canvas.width * 0.01, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawEnemies() {
            gameState.enemies.forEach(enemy => {
                ctx.fillStyle = enemy.color;
                ctx.beginPath();
                ctx.moveTo(enemy.x - enemy.width / 2, enemy.y - enemy.height / 2);
                ctx.lineTo(enemy.x + enemy.width / 2, enemy.y - enemy.height / 2);
                ctx.lineTo(enemy.x, enemy.y + enemy.height / 2);
                ctx.closePath();
                ctx.fill();
            });
        }

        function moveBullets() {
            gameState.bullets.forEach(bullet => {
                bullet.y -= gameState.bulletSpeed;
            });
            gameState.bullets = gameState.bullets.filter(bullet => bullet.y > 0);
        }

        function moveEnemies() {
            gameState.enemies.forEach(enemy => {
                enemy.y += enemy.speed;
            });
        }

        function checkEscapedEnemies() {
            const escapedEnemies = gameState.enemies.filter(enemy => enemy.y > canvas.height);
            escapedEnemies.forEach(enemy => {
                const penaltyScore = 5;
                gameState.score = Math.max(0, gameState.score - penaltyScore);
                gameState.penaltyScores.push({
                    x: enemy.x,
                    y: canvas.height,
                    score: penaltyScore,
                    age: 0
                });
            });
            gameState.enemies = gameState.enemies.filter(enemy => enemy.y <= canvas.height);
        }

        function spawnEnemy() {
            if (Math.random() < 0.03) {
                const enemyType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
                const size = canvas.width * (enemyType.size / 400);
                gameState.enemies.push({
                    x: Math.random() * canvas.width,
                    y: 0,
                    width: size,
                    height: size,
                    speed: (Math.random() * 3 + 2) * (canvas.height / 600),
                    color: enemyType.color,
                    score: enemyType.score
                });
            }
        }

        function checkCollisions() {
            for (let i = gameState.bullets.length - 1; i >= 0; i--) {
                const bullet = gameState.bullets[i];
                for (let j = gameState.enemies.length - 1; j >= 0; j--) {
                    const enemy = gameState.enemies[j];
                    if (bullet.x > enemy.x - enemy.width / 2 && bullet.x < enemy.x + enemy.width / 2 &&
                        bullet.y > enemy.y - enemy.height / 2 && bullet.y < enemy.y + enemy.height / 2) {
                        gameState.enemies.splice(j, 1);
                        gameState.bullets.splice(i, 1);
                        gameState.score += enemy.score;
                        gameState.scoreDisplays.push({
                            x: enemy.x,
                            y: enemy.y,
                            score: enemy.score,
                            age: 0
                        });
                        break;
                    }
                }
            }

            gameState.enemies.forEach(enemy => {
                if (gameState.player.x - gameState.player.width / 2 < enemy.x + enemy.width / 2 &&
                    gameState.player.x + gameState.player.width / 2 > enemy.x - enemy.width / 2 &&
                    gameState.player.y - gameState.player.height / 2 < enemy.y + enemy.height / 2 &&
                    gameState.player.y + gameState.player.height / 2 > enemy.y - enemy.height / 2) {
                    gameState.isGameOver = true;
                }
            });
        }

        function drawScore() {
            ctx.fillStyle = '#00fff5';
            ctx.font = `bold ${canvas.width * 0.05}px Arial`;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText(`Score: ${gameState.score}`, canvas.width * 0.05, canvas.height * 0.05);
        }

        function drawScoreDisplays() {
            ctx.font = `bold ${canvas.width * 0.04}px Arial`;
            for (let i = gameState.scoreDisplays.length - 1; i >= 0; i--) {
                const display = gameState.scoreDisplays[i];
                ctx.fillStyle = `rgba(255, 255, 255, ${1 - display.age / 60})`;
                ctx.fillText(`+${display.score}`, display.x, display.y);
                display.y -= canvas.height * 0.001;
                display.age++;
                if (display.age > 60) {
                    gameState.scoreDisplays.splice(i, 1);
                }
            }
        }

        function drawPenaltyScores() {
            ctx.font = `bold ${canvas.width * 0.04}px Arial`;
            for (let i = gameState.penaltyScores.length - 1; i >= 0; i--) {
                const penalty = gameState.penaltyScores[i];
                ctx.fillStyle = `rgba(255, 0, 0, ${1 - penalty.age / 60})`;
                ctx.fillText(`-${penalty.score}`, penalty.x, penalty.y);
                penalty.y -= canvas.height * 0.001;
                penalty.age++;
                if (penalty.age > 60) {
                    gameState.penaltyScores.splice(i, 1);
                }
            }
        }

        function drawGameOver() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#00fff5';
            ctx.font = `bold ${canvas.width * 0.1}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
            ctx.font = `bold ${canvas.width * 0.05}px Arial`;
            ctx.fillText(`Final Score: ${gameState.score}`, canvas.width / 2, canvas.height / 2 + canvas.height * 0.1);
            ctx.fillText('Tap to Restart', canvas.width / 2, canvas.height / 2 + canvas.height * 0.2);
        }

        function autoShoot() {
            const currentTime = Date.now();
            if (currentTime - gameState.lastShotTime >= 250) {
                gameState.bullets.push({
                    x: gameState.player.x,
                    y: gameState.player.y - gameState.player.height / 2
                });
                gameState.lastShotTime = currentTime;
            }
        }

        function gameLoop() {
            drawBackground();
            
            if (!gameState.isGameOver) {
                moveEnemies();
                checkEscapedEnemies();
                moveBullets();
                spawnEnemy();
                checkCollisions();
                autoShoot();

                drawPlayer();
                drawBullets();
                drawEnemies();
                drawScore();
                drawScoreDisplays();
                drawPenaltyScores();
            } else {
                drawGameOver();
            }
            
            requestAnimationFrame(gameLoop);
        }

        function initGame() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            // キャンバスサイズを画面サイズに合わせる
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // プレイヤーのサイズを画面サイズに合わせて調整
            gameState.player.width = canvas.width * 0.1;
            gameState.player.height = canvas.width * 0.125;
            
            gameState.player.x = canvas.width / 2;
            gameState.player.y = canvas.height - gameState.player.height;

            // 背景パターンを作成
            backgroundPattern = createBackgroundPattern();

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!gameState.isGameOver) {
                    const touch = e.touches[0];
                    const rect = canvas.getBoundingClientRect();
                    gameState.player.x = touch.clientX - rect.left;
                }
            });

            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (gameState.isGameOver) {
                    restartGame();
                }
            });

            gameLoop();
        }

        function restartGame() {
            gameState.player.x = canvas.width / 2;
            gameState.bullets
